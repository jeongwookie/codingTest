"""
어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행한다.
1. N에서 1을 뺀다
2. N을 K로 나눈다 : 해당 연산은 N이 K로 나누어떨어질 때만 수행한다.

예) N이 17일때, 1을 빼고 4로 나눈걸 두번하면 1이된다. 전체 수행 횟수는 3
N이 1이 될때까지 과정을 수행해야 하는 최소 횟수를 리턴하라.
"""

def solution(N, K):
    """
    가능한 K를 나누는 과정을 많이 해야한다. -> 그리디 알고리즘
    왜냐하면, 가장 작은 수인 K에 대해서도 1을 빼는 것보다 훨씬 빠르게 1로 수렴시킬수 있기 때문이다.
    While문 한번 돌때마다 과정 1과 2를 모두 수행하는 코드 : O(logN)으로 수행할 수 있음.
    target = (N // K) * K 해당 테크닉은 기억해 놓는게 좋을듯.
    """
    count = 0
    while True:
        target = (N // K) * K # K로 나누어떨어지는 가장 N에 가까운 수
        count += N - target # N과의 차 만큼 과정 1을 반복했으니 count변수에 더해줌

        N = target # N을 K로 나누어떨어지는 수로 업데이트

        if N < K: # N이 K보다 작을 경우, 더이상 나누어떨어지지 않음.
            break

        N = N // K # N을 K로 나눠줌
        count += 1

    # 루프를 끝냈을때, N이 1보다 크거나 같을 수 있음. K로 나눠주는 연산을 최대로 수행했기때문에,
    ## 1을 빼주는 연산으로 마무리하면 됨. 6이 나왔다면 count는 5번 올라가겠지?
    count += (N - 1)
    return count

if __name__ == "__main__":
    N = 25
    K = 5
    print(solution(N, K))